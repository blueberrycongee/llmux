# Bug 修复与设计分析日志

本文档记录了 LLMux 项目在近期深度审计中发现的问题，并将其区分为“设计取舍”与“实现漏洞”。

## 🛠️ 实现漏洞 (Bugs & Vulnerabilities)
这些属于代码实现上的错误，如果不修复，在生产环境下会导致服务崩溃或资源泄露。

### 1. APIKey 并发安全修复 (Data Race)
- **性质**：**实现漏洞**。
- **问题**：`MemoryStore` 返回结构体的浅拷贝，导致多个协程并发读写其中的 Map 字段（如 `ModelSpend`），这违反了 Go 的并发安全准则，会导致不可预知的崩溃。
- **修复**：引入 `Clone()` 深度拷贝机制。
- **风险**：🚨 高

### 2. 流式传输 Context 泄露
- **性质**：**实现漏洞**。
- **问题**：`Forward()` 方法未确保 `cancel()` 函数被调用，导致请求结束后子 Context 仍占用内存/系统资源。
- **修复**：添加 `defer cancel()`。
- **风险**：⚠️ 中

### 3. 全局 Panic 恢复缺失
- **性质**：**实现漏洞/稳定性缺陷**。
- **问题**：缺少全局捕获 Panic 的中间件，导致异常发生时服务无法返回结构化响应且记录日志不全。
- **修复**：在入口处添加 `recoveryMiddleware`。
- **风险**：⚠️ 中

## 📐 设计取舍 (Design Trade-offs)
这些曾是基于开发效率、性能或系统复杂度的权衡，但在追求“前沿开源方案”的过程中我们进行了升级。

### 1. 从硬编码鉴权到 Casbin (RBAC 演进)
- **取舍前**：硬编码在中间件中的角色检查。优点是逻辑直观、开发极快；缺点是策略调整需重新编译代码，不具备动态性。
- **优化后**：引入 **Casbin**。增加了少量的学习成本和配置复杂度，但获得了工业级的权限动态管控能力。

### 2. 从静态负载均衡到 EWMA 路由
- **取舍前**：简单的轮询或静态权重。优点是 CPU 损耗极低，逻辑极其稳定；缺点是无法感知供应商的实时性能抖动。
- **优化后**：引入 **EWMA (指数加权移动平均)**。增加了一定的内存统计开销，但显著提升了系统对不稳定上游的自适应规避能力。

### 3. 从 Top-1 语义检索到 Top-N 重排序 (Re-ranking)
- **取舍前**：仅取向量相似度最高的 Top-1 缓存结果。优点是速度最快，延迟最低；缺点是容易因语义相似但细节不同的 Prompt 导致“幻觉命中”。
- **优化后**：引入 **Top-N + 重排序**。增加了二次精筛的时间开销，但极大提升了缓存命中的准确度和系统可信度。

### 4. 从固定限流到自适应限流 (Adaptive Limiting)
- **取舍前**：基于预设固定值的 TPM/RPM 限流。优点是行为完全可预测；缺点是无法根据后端实时压力自动调整吞吐。
- **优化后**：引入 **Adaptive Limiter**。逻辑更复杂，但实现了真正的系统自保护。

---
**验证状态**：所有修复均已通过开启 `-race` 标志的回归测试。
